In our process of generation of the raw data, We have only two files that can produce `.csv` files (or to be more precise which execution takes enough time that it makes sense to save their output in a `.csv` file, therfore a data-versioning convention is needed):

* [Milestone1/json_scrapper.py](../Milestone1/json_scrapper.py) : scrapes the json files and generates a `.csv` file

* [Milestone2/features_engineering.py](../Milestone2/features_engineering.py) : performs engineering (Read our blog) features from the `.csv` file generated by `json_scrapper.py` and generates a `.csv` file

# Lineage in `json_scrapper_output`

Exclusively based on the git commit of the [Milestone1/json_scrapper.py](../Milestone1/json_scrapper.py) file and which season(s) were scraped.
Hence, the following naming of the csv files `json_scrapper_output/raw_data_2016_2020_b15700b.csv` 
Git commit are taken from the command (`git log --all Milestone1/json_scrapper.py`)

We could have taken as input of variables parameters also the version of the NHL API ...

# Lineage in `features_engineering_output`

For this part, there is a lot more factors that could the data produced. For instance, all the parameters present in the `__init__` of class `FeaturesEngineering` in [Milestone2/features_engineering.py](../Milestone2/features_engineering.py) could be considered as parameters of the lineage.

Hence, as first parameter of data changing is the .csv file produced by `json_scrapper.py` taken as input in the data-engineering pipeline.
Then, the code written in [Milestone2/features_engineering.py](../Milestone2/features_engineering.py) is also a parameter of the lineage. So we associate a version with this last (for example, if we add more significative feature engineering, it will be worth to increment version).
Therefore, the dirs `v1/raw_data_2016_2020_b15700b/` under `features_engineering_output/`.

Then to encode how we did the actual feature engineering, we give each method a unique id (hence the dir `103` which corresponds to all value equals to True in the parameters of the `__init__` of class `FeaturesEngineering` in [Milestone2/features_engineering.py](../Milestone2/features_engineering.py)).


We understand that we can get lost among all those parameters. So, we keep updated a SQLITE file that contains all those above associated to every .csv file under `features_engineering_output/vX` (see example [info_1.db](./feature_engineering_output/v1/info_1.db) to will contain informations of creation of .csv file under `features_engineering_output/v1`).


Furthermore, we log to COMET every .csv file that we created. Two projects were created in COMET, one for csv in `json_scrapper_output` and one for csv in `features_engineering_output`.

Finally, thanks to those above conventions established among our team, we are able to keep track of our data and to reproduce our results. 

Note also